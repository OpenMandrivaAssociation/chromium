commit e7d10047096880feb5e9846375f2da54aef91202
Author: Ted Meyer <tmathmeyer@chromium.org>
Date:   Wed Mar 20 15:32:19 2024 -0700

    Remove usage of AVCodecContext::reordered_opaque
    
    FFmpeg has removed this field and usage of it in chromium must be
    removed before the ffmpeg dependency is updated. The chromium media
    change can be found here:
    https://chromium-review.googlesource.com/c/chromium/src/+/5384308
    
    The usage of the field in webrtc seems only to be for sanity checking,
    so it should be just safe to remove entirely, since webrtc does not
    expect re-ordering at all.
    
    Bug: chromium:330573128
    Change-Id: I9c5854ec82c3ad2d55374ea4eaa0c571437f8267
    Reviewed-on: https://webrtc-review.googlesource.com/c/src/+/343840
    Reviewed-by: Erik Språng <sprang@webrtc.org>
    Commit-Queue: Ted (Chromium) Meyer <tmathmeyer@chromium.org>
    Cr-Commit-Position: refs/heads/main@{#41935}

diff --git a/modules/video_coding/codecs/h264/h264_decoder_impl.cc b/modules/video_coding/codecs/h264/h264_decoder_impl.cc
index f02caa18ef..feceb37716 100644
--- a/modules/video_coding/codecs/h264/h264_decoder_impl.cc
+++ b/modules/video_coding/codecs/h264/h264_decoder_impl.cc
@@ -233,7 +233,6 @@ int H264DecoderImpl::AVGetBuffer2(AVCodecContext* context,
   int total_size = y_size + 2 * uv_size;
 
   av_frame->format = context->pix_fmt;
-  av_frame->reordered_opaque = context->reordered_opaque;
 
   // Create a VideoFrame object, to keep a reference to the buffer.
   // TODO(nisse): The VideoFrame's timestamp and rotation info is not used.
@@ -381,8 +380,6 @@ int32_t H264DecoderImpl::Decode(const EncodedImage& input_image,
     return WEBRTC_VIDEO_CODEC_ERROR;
   }
   packet->size = static_cast<int>(input_image.size());
-  int64_t frame_timestamp_us = input_image.ntp_time_ms_ * 1000;  // ms -> μs
-  av_context_->reordered_opaque = frame_timestamp_us;
 
   int result = avcodec_send_packet(av_context_.get(), packet.get());
 
@@ -399,10 +396,6 @@ int32_t H264DecoderImpl::Decode(const EncodedImage& input_image,
     return WEBRTC_VIDEO_CODEC_ERROR;
   }
 
-  // We don't expect reordering. Decoded frame timestamp should match
-  // the input one.
-  RTC_DCHECK_EQ(av_frame_->reordered_opaque, frame_timestamp_us);
-
   // TODO(sakal): Maybe it is possible to get QP directly from FFmpeg.
   h264_bitstream_parser_.ParseBitstream(input_image);
   absl::optional<int> qp = h264_bitstream_parser_.GetLastSliceQp();
