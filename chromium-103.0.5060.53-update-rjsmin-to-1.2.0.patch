diff -up chromium-103.0.5060.53/third_party/catapult/common/py_vulcanize/third_party/rjsmin/rjsmin.c.12 chromium-103.0.5060.53/third_party/catapult/common/py_vulcanize/third_party/rjsmin/rjsmin.c
--- chromium-103.0.5060.53/third_party/catapult/common/py_vulcanize/third_party/rjsmin/rjsmin.c.12	2022-06-28 12:50:10.167324583 +0000
+++ chromium-103.0.5060.53/third_party/catapult/common/py_vulcanize/third_party/rjsmin/rjsmin.c	2021-11-14 19:50:55.000000000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright 2011 - 2015
+ * Copyright 2011 - 2021
  * Andr\xe9 Malo or his licensors, as applicable
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -18,21 +18,21 @@
 #include "cext.h"
 EXT_INIT_FUNC;
 
-#define RJSMIN_DULL_BIT           (1 << 0)
-#define RJSMIN_PRE_REGEX_BIT      (1 << 1)
-#define RJSMIN_REGEX_DULL_BIT     (1 << 2)
-#define RJSMIN_REGEX_CC_DULL_BIT  (1 << 3)
-#define RJSMIN_ID_LIT_BIT         (1 << 4)
-#define RJSMIN_ID_LIT_O_BIT       (1 << 5)
-#define RJSMIN_ID_LIT_C_BIT       (1 << 6)
-#define RJSMIN_STRING_DULL_BIT    (1 << 7)
-#define RJSMIN_SPACE_BIT          (1 << 8)
-#define RJSMIN_POST_REGEX_OFF_BIT (1 << 9)
+#define RJSMIN_DULL_BIT           (1 <<  0)
+#define RJSMIN_PRE_REGEX_BIT      (1 <<  1)
+#define RJSMIN_REGEX_DULL_BIT     (1 <<  2)
+#define RJSMIN_REGEX_CC_DULL_BIT  (1 <<  3)
+#define RJSMIN_ID_LIT_BIT         (1 <<  4)
+#define RJSMIN_ID_LIT_O_BIT       (1 <<  5)
+#define RJSMIN_ID_LIT_C_BIT       (1 <<  6)
+#define RJSMIN_STRING_DULL_BIT    (1 <<  7)
+#define RJSMIN_SPACE_BIT          (1 <<  8)
+#define RJSMIN_POST_REGEX_OFF_BIT (1 <<  9)
+#define RJSMIN_A_Z_BIT            (1 << 10)
 
-#ifdef EXT3
-typedef Py_UNICODE rchar;
-#else
 typedef unsigned char rchar;
+#ifdef U
+#undef U
 #endif
 #define U(c) ((rchar)(c))
 
@@ -66,66 +66,120 @@ typedef unsigned char rchar;
 #define RJSMIN_IS_PRE_REGEX_1(c) ((U(c) <= 127) && \
     (rjsmin_charmask[U(c) & 0x7F] & RJSMIN_PRE_REGEX_BIT))
 
+#define RJSMIN_IS_A_Z(c) ((U(c) <= 127) && \
+    (rjsmin_charmask[U(c) & 0x7F] & RJSMIN_A_Z_BIT))
+
 
 static const unsigned short rjsmin_charmask[128] = {
-    396, 396, 396, 396, 396, 396, 396, 396,
-    396, 396,   2, 396, 396,   2, 396, 396,
-    396, 396, 396, 396, 396, 396, 396, 396,
-    396, 396, 396, 396, 396, 396, 396, 396,
-    396, 687, 588, 653, 765, 653, 143, 588,
-    687, 205, 653, 237, 143, 237, 141, 648,
-    765, 765, 765, 765, 765, 765, 765, 765,
-    765, 765, 143, 143, 653, 143, 653, 143,
-    653, 765, 765, 765, 765, 765, 765, 765,
-    765, 765, 765, 765, 765, 765, 765, 765,
-    765, 765, 765, 765, 765, 765, 765, 765,
-    765, 765, 765, 683, 513, 197, 653, 765,
-    653, 765, 765, 765, 765, 765, 765, 765,
-    765, 765, 765, 765, 765, 765, 765, 765,
-    765, 765, 765, 765, 765, 765, 765, 765,
-    765, 765, 765, 687, 143, 207, 653, 765
+     396,  396,  396,  396,  396,  396,  396,  396,
+     396,  396,    2,  396,  396,    2,  396,  396,
+     396,  396,  396,  396,  396,  396,  396,  396,
+     396,  396,  396,  396,  396,  396,  396,  396,
+     396,  687,  588,  653,  765,  653,  143,  588,
+     687,  205,  655,  239,  143,  239,  141,  648,
+     765,  765,  765,  765,  765,  765,  765,  765,
+     765,  765,  143,  143,  653,  143,  653,  143,
+     653,  765,  765,  765,  765,  765,  765,  765,
+     765,  765,  765,  765,  765,  765,  765,  765,
+     765,  765,  765,  765,  765,  765,  765,  765,
+     765,  765,  765,  683,  513,  197,  653,  765,
+     588, 1789, 1789, 1789, 1789, 1789, 1789, 1789,
+    1789, 1789, 1789, 1789, 1789, 1789, 1789, 1789,
+    1789, 1789, 1789, 1789, 1789, 1789, 1789, 1789,
+    1789, 1789, 1789,  687,  143,  207,  653,  765
 };
 
+
 static Py_ssize_t
 rjsmin(const rchar *source, rchar *target, Py_ssize_t length,
        int keep_bang_comments)
 {
-    const rchar *reset, *pcreset = NULL, *pctoken = NULL, *xtarget,
-                *sentinel = source + length;
-    rchar *tstart = target;
-    int post_regex = 0;
-    rchar c, quote, spaced = U(' ');
+    const rchar
+        *sentinel = source + length, /* never hit this pointer (source buf) */
+        *reset,          /* reset pointer (source buf) */
+        *pcreset = NULL, /* pre-comment reset pointer (source buf) */
+        *pctoken = NULL, /* pre-comment token pointer (target buf)
+                          * Pointing to before the last kept comment, if any */
+        *rsreset = NULL, /* regex-with-method reset pointer (source buf) */
+        *xtarget;        /* pre-regex-2 target pointer */
+
+    rchar *tstart = target, /* Target start pointer for reference */
+        *rtreset = NULL;    /* regex-with-method reset pointer (target buf) */
+
+    int rsdot,              /* seen dot after regex-with-method pattern? */
+        post_regex = 0;
+    rchar c, quote,
+        spaced = U(' ');    /* the last seen kind of space (nl taking prio),
+                             * init with ' ' */
 
+    /* main loop */
     while (source < sentinel) {
         c = *source++;
+
         if (RJSMIN_IS_DULL(c)) {
             if (post_regex) post_regex = 0;
             if (pctoken) pctoken = NULL;
             if (spaced == U('\n')) spaced = U(' ');
+            if (rsreset) {
+                /* both a-z and . are covered by "dull" */
+                if (!rsdot) {
+                    if (c != U('.')) {
+                        /* reset regex-with-method to the starting slash */
+                        source = rsreset;
+                        target = rtreset;
+                        rsreset = NULL;
+                        continue; /* main loop */
+                    }
+                    /* Found a dot after possible regex, looking for a-z now */
+                    rsdot = 1;
+                }
+                else if (!RJSMIN_IS_A_Z(c)) {
+                    /* reset regex-with-method to the starting slash */
+                    source = rsreset;
+                    target = rtreset;
+                    rsreset = NULL;
+                    continue; /* main loop */
+                }
+                else {
+                    /* Successfull finish the regex-with-method match */
+                    rsreset = NULL;
+                }
+            }
 
             *target++ = c;
-            continue;
+            continue; /* main loop */
         }
+
         switch (c) {
 
         /* String */
-        case U('\''): case U('"'):
+        case U('\''): case U('"'): case U('`'):
             if (post_regex) post_regex = 0;
             if (pctoken) pctoken = NULL;
             if (spaced == U('\n')) spaced = U(' ');
+            if (rsreset) {
+                /* reset regex-with-method to the starting slash */
+                source = rsreset;
+                target = rtreset;
+                rsreset = NULL;
+                continue; /* main loop */
+            }
 
             reset = source;
             *target++ = quote = c;
+
+            /* string loop */
             while (source < sentinel) {
                 c = *source++;
                 *target++ = c;
                 if (RJSMIN_IS_STRING_DULL(c))
-                    continue;
+                    continue; /* string loop */
+
                 switch (c) {
-                case U('\''): case U('"'):
+                case U('\''): case U('"'): case U('`'):
                     if (c == quote)
-                        goto cont;
-                    continue;
+                        goto cont; /* main loop */
+                    continue; /* string loop */
                 case U('\\'):
                     if (source < sentinel) {
                         c = *source++;
@@ -134,13 +188,18 @@ rjsmin(const rchar *source, rchar *targe
                             && *source == U('\n'))
                             *target++ = *source++;
                     }
-                    continue;
+                    continue; /* string loop */
+                case U('\r'): case U('\n'):
+                    if (quote != U('`'))
+                        break; /* string reset */
+                    continue; /* string loop */
                 }
-                break;
+                break; /* string reset */
             }
+            /* string reset */
             target -= source - reset;
             source = reset;
-            continue;
+            continue; /* main loop */
 
         /* Comment or Regex or something else entirely */
         case U('/'):
@@ -148,6 +207,13 @@ rjsmin(const rchar *source, rchar *targe
                 if (post_regex) post_regex = 0;
                 if (pctoken) pctoken = NULL;
                 if (spaced == U('\n')) spaced = U(' ');
+                if (rsreset) {
+                    /* reset regex-with-method to the starting slash */
+                    source = rsreset;
+                    target = rtreset;
+                    rsreset = NULL;
+                    continue; /* main loop */
+                }
 
                 *target++ = c;
             }
@@ -157,7 +223,19 @@ rjsmin(const rchar *source, rchar *targe
                 case U('*'): case U('/'):
                     goto skip_or_copy_ws;
 
+            /* Regex or slash */
                 default:
+                    if (rsreset) {
+                        /* reset regex-with-method to the starting slash */
+                        if (post_regex) post_regex = 0;
+                        if (pctoken) pctoken = NULL;
+                        if (spaced == U('\n')) spaced = U(' ');
+                        source = rsreset;
+                        target = rtreset;
+                        rsreset = NULL;
+                        continue; /* main loop */
+                    }
+
                     xtarget = NULL;
                     if (   target == tstart
                         || RJSMIN_IS_PRE_REGEX_1(*((pctoken ? pctoken : target)
@@ -176,99 +254,148 @@ rjsmin(const rchar *source, rchar *targe
                                 || !RJSMIN_IS_ID_LITERAL(*(xtarget - 7))
                             )
                         )) {
-
-            /* Regex */
+                        /* nothing to do here, continuing down below
+                         * We could unset rsreset here, but we know it already
+                         * is. */
+                        ;
+                    }
+                    else if (*((pctoken ? pctoken : target) - 1) == U(')')) {
+                        xtarget = NULL;
+                        rsreset = source;
+                        rtreset = target + 1;
+                        rsdot = 0;
+                    }
+                    else {
+                        /* Just a slash */
                         if (post_regex) post_regex = 0;
                         if (pctoken) pctoken = NULL;
+                        if (spaced == U('\n')) spaced = U(' ');
 
-                        reset = source;
-                        if (spaced == U('\n')) {
-                            spaced = U(' ');
-                            if (xtarget)
-                                *target++ = U('\n');
-                        }
+                        *target++ = c;
+                        continue; /* main loop */
+                    }
 
-                        *target++ = U('/');
-                        while (source < sentinel) {
-                            c = *source++;
-                            *target++ = c;
-                            if (RJSMIN_IS_REGEX_DULL(c))
-                                continue;
-                            switch (c) {
-                            case U('/'):
-                                post_regex = 1;
-                                goto cont;
-                            case U('\\'):
-                                if (source < sentinel) {
-                                    c = *source++;
-                                    *target++ = c;
-                                    if (c == U('\r') || c == U('\n'))
-                                        break;
-                                }
-                                continue;
-                            case U('['):
-                                while (source < sentinel) {
-                                    c = *source++;
-                                    *target++ = c;
-                                    if (RJSMIN_IS_REGEX_CC_DULL(c))
-                                        continue;
-                                    switch (c) {
-                                    case U('\\'):
-                                        if (source < sentinel) {
-                                            c = *source++;
-                                            *target++ = c;
-                                            if (c == U('\r') || c == U('\n'))
-                                                break;
-                                        }
-                                        continue;
-                                    case U(']'):
-                                        goto cont_regex;
+                    if (post_regex) post_regex = 0;
+                    if (pctoken) pctoken = NULL;
+
+                    reset = source;
+                    if (spaced == U('\n')) {
+                        spaced = U(' ');
+                        if (xtarget)
+                            *target++ = U('\n');
+                    }
+
+                    *target++ = U('/');
+
+                    /* regex loop */
+                    while (source < sentinel) {
+                        c = *source++;
+                        *target++ = c;
+
+                        if (RJSMIN_IS_REGEX_DULL(c))
+                            continue; /* regex loop */
+
+                        switch (c) {
+                        case U('/'):
+                            while (source < sentinel
+                                   && RJSMIN_IS_A_Z(*source))
+                                *target++ = *source++;
+                            post_regex = !rsreset;
+                            /* This check is supposed to make it faster.
+                             * It doesn't. It slows it down. I wonder why...
+                             */
+                            /*
+                             * if (!post_regex
+                             *     && source < sentinel - 1
+                             *     && *source == U('.')
+                             *     && RJSMIN_IS_A_Z(*(source + 1)))
+                             *     rsreset = NULL;
+                             */
+
+                            goto cont; /* main loop */
+
+                        case U('\\'):
+                            if (source < sentinel) {
+                                c = *source++;
+                                *target++ = c;
+                                if (c == U('\r') || c == U('\n'))
+                                    break; /* regex reset */
+                            }
+                            continue; /* regex loop */
+
+                        case U('['):
+                            /* regex CC loop */
+                            while (source < sentinel) {
+                                c = *source++;
+                                *target++ = c;
+
+                                if (RJSMIN_IS_REGEX_CC_DULL(c))
+                                    continue; /* regex CC loop */
+
+                                switch (c) {
+                                case U('\\'):
+                                    if (source < sentinel) {
+                                        c = *source++;
+                                        *target++ = c;
+                                        if (c == U('\r') || c == U('\n'))
+                                            break; /* regex reset */
                                     }
+                                    continue; /* regex CC loop */
+
+                                case U(']'):
+                                    goto cont_regex; /* regex loop */
                                 }
-                                break;
                             }
-                            break;
-                        cont_regex:
-                            continue;
+                            break; /* regex reset */
+
                         }
-                        target -= source - reset;
-                        source = reset;
-                    }
-                    else {
-            /* Just a slash */
-                        if (post_regex) post_regex = 0;
-                        if (pctoken) pctoken = NULL;
-                        if (spaced == U('\n')) spaced = U(' ');
+                        break; /* regex reset */
 
-                        *target++ = c;
+                    cont_regex:
+                        continue; /* regex loop */
                     }
-                    continue;
+
+                    /* regex reset */
+                    target -= source - reset;
+                    source = reset;
+                    rsreset = NULL;
+                    continue; /* main loop */
                 }
             }
-            continue;
+            continue;  /* main loop */ /* LCOV_EXCL_LINE */
 
         /* Whitespace */
         default:
         skip_or_copy_ws:
+            /* remember if we've seen a newline, start with: no */
             quote = U(' ');
             --source;
+
+            /* space loop */
             while (source < sentinel) {
                 c = *source++;
                 if (RJSMIN_IS_SPACE(c))
-                    continue;
+                    continue; /* space loop */
+
                 switch (c) {
                 case U('\r'): case U('\n'):
                     quote = U('\n');
-                    continue;
+                    continue; /* space loop */
+
+                /* Can only be a comment at this point
+                 * (or ending prematurely) */
                 case U('/'):
                     if (source < sentinel) {
                         switch (*source) {
+
+                        /* multiline comment */
                         case U('*'):
                             reset = source++;
                             /* copy bang comment, if requested */
                             if (   keep_bang_comments && source < sentinel
                                 && *source == U('!')) {
                                 if (!pctoken) {
+                                    /* Backtracking if ending prematurely */
                                     pctoken = target;
                                     pcreset = reset;
                                 }
@@ -276,6 +403,8 @@ rjsmin(const rchar *source, rchar *targe
                                 *target++ = U('/');
                                 *target++ = U('*');
                                 *target++ = *source++;
+
+                                /* comment loop */
                                 while (source < sentinel) {
                                     c = *source++;
                                     *target++ = c;
@@ -283,20 +412,21 @@ rjsmin(const rchar *source, rchar *targe
                                         && *source == U('/')) {
                                         *target++ = *source++;
                                         reset = NULL;
-                                        break;
+                                        break; /* continue space loop */
                                     }
                                 }
                                 if (!reset)
-                                    continue;
+                                    continue; /* space loop */
 
+                                /* comment reset */
                                 target -= source - reset;
                                 source = reset;
                                 if (pcreset == reset) {
                                     pctoken = NULL;
                                     pcreset = NULL;
                                 }
-
                             }
+
                             /* strip regular comment */
                             else {
                                 while (source < sentinel) {
@@ -305,41 +435,52 @@ rjsmin(const rchar *source, rchar *targe
                                         && *source == U('/')) {
                                         ++source;
                                         reset = NULL;
-                                        break;
+                                        break; /* continue space loop */
                                     }
                                 }
                                 if (!reset)
-                                    continue;
+                                    continue; /* space loop */
+
+                                /* comment reset: fallback to slash */
                                 source = reset;
                                 *target++ = U('/');
                             }
-                            goto cont;
+                            goto cont; /* main loop */
+
+                        /* single line comment */
                         case U('/'):
                             ++source;
+
+                            /* single line comment loop */
                             while (source < sentinel) {
                                 c = *source++;
                                 switch (c) {
                                 case U('\n'):
-                                    break;
+                                    break; /* continue space loop */
+
                                 case U('\r'):
                                     if (source < sentinel
                                         && *source == U('\n'))
                                         ++source;
-                                    break;
+                                    break; /* continue space loop */
+
                                 default:
-                                    continue;
+                                    continue; /* single line comment loop */
                                 }
-                                break;
+                                break; /* continue space loop */
                             }
                             quote = U('\n');
-                            continue;
+                            continue; /* space loop */
                         }
                     }
                 }
+
+                /* No more spacy character found */
                 --source;
-                break;
+                break; /* end space loop */
             }
 
+            /* Copy a space if needed */
             if ((tstart < (pctoken ? pctoken : target) && source < sentinel)
                 && ((quote == U('\n')
                      && ((RJSMIN_IS_ID_LITERAL_CLOSE(*((pctoken ?
@@ -363,8 +504,9 @@ rjsmin(const rchar *source, rchar *targe
             pcreset = NULL;
             spaced = quote;
         }
+
     cont:
-        continue;
+        continue; /* main loop */
     }
     return (Py_ssize_t)(target - tstart);
 }
@@ -385,15 +527,15 @@ substitution regex.\n\
 :Note: This is a hand crafted C implementation built on the regex\n\
        semantics.\n\
 \n\
-:Parameters:\n\
-  `script` : ``str``\n\
+Parameters:\n\
+  script (str):\n\
     Script to minify\n\
 \n\
-  `keep_bang_comments` : ``bool``\n\
+  keep_bang_comments (bool):\n\
     Keep comments starting with an exclamation mark? (``/*!...*/``)\n\
 \n\
-:Return: Minified script\n\
-:Rtype: ``str``");
+Returns:\n\
+  str: Minified script");
 
 static PyObject *
 rjsmin_jsmin(PyObject *self, PyObject *args, PyObject *kwds)
@@ -404,15 +546,15 @@ rjsmin_jsmin(PyObject *self, PyObject *a
     int keep_bang_comments;
 #ifdef EXT2
     int uni;
-#define UOBJ "O"
 #endif
 #ifdef EXT3
-#define UOBJ "U"
+    int bytes;
+    rchar *bytescript;
 #endif
 
-    if (!PyArg_ParseTupleAndKeywords(args, kwds, UOBJ "|O", kwlist,
+    if (!PyArg_ParseTupleAndKeywords(args, kwds, "O|O", kwlist,
                                      &script, &keep_bang_comments_))
-        return NULL;
+        LCOV_EXCL_LINE_RETURN(NULL);
 
     if (!keep_bang_comments_)
         keep_bang_comments = 0;
@@ -425,28 +567,27 @@ rjsmin_jsmin(PyObject *self, PyObject *a
 #ifdef EXT2
     if (PyUnicode_Check(script)) {
         if (!(script = PyUnicode_AsUTF8String(script)))
-            return NULL;
+            LCOV_EXCL_LINE_RETURN(NULL);
         uni = 1;
     }
+    else if (!PyString_Check(script)) {
+        PyErr_SetString(PyExc_TypeError, "Unexpected type");
+        return NULL;
+    }
     else {
         if (!(script = PyObject_Str(script)))
-            return NULL;
+            LCOV_EXCL_LINE_RETURN(NULL);
         uni = 0;
     }
-#endif
-
-#ifdef EXT3
-    Py_INCREF(script);
-#define PyString_GET_SIZE PyUnicode_GET_SIZE
-#define PyString_AS_STRING PyUnicode_AS_UNICODE
-#define _PyString_Resize PyUnicode_Resize
-#define PyString_FromStringAndSize PyUnicode_FromUnicode
-#endif
-
     slength = PyString_GET_SIZE(script);
+
     if (!(result = PyString_FromStringAndSize(NULL, slength))) {
+        LCOV_EXCL_START
+
         Py_DECREF(script);
         return NULL;
+
+        LCOV_EXCL_STOP
     }
     Py_BEGIN_ALLOW_THREADS
     length = rjsmin((rchar *)PyString_AS_STRING(script),
@@ -456,30 +597,97 @@ rjsmin_jsmin(PyObject *self, PyObject *a
 
     Py_DECREF(script);
     if (length < 0) {
+        LCOV_EXCL_START
+
         Py_DECREF(result);
         return NULL;
+
+        LCOV_EXCL_STOP
     }
     if (length != slength && _PyString_Resize(&result, length) == -1)
-        return NULL;
+        LCOV_EXCL_LINE_RETURN(NULL);
 
-#ifdef EXT2
     if (uni) {
         script = PyUnicode_DecodeUTF8(PyString_AS_STRING(result),
                                       PyString_GET_SIZE(result), "strict");
         Py_DECREF(result);
-        if (!script)
-            return NULL;
-        result = script;
+        return script;
     }
-#endif
+
     return result;
+
+#else  /* EXT3 */
+
+    if (PyUnicode_Check(script)) {
+        bytes = 0;
+        script = PyUnicode_AsUTF8String(script);
+        bytescript = (rchar *)PyBytes_AS_STRING(script);
+        slength = PyBytes_GET_SIZE(script);
+    }
+    else if (PyBytes_Check(script)) {
+        bytes = 1;
+        Py_INCREF(script);
+        bytescript = (rchar *)PyBytes_AS_STRING(script);
+        slength = PyBytes_GET_SIZE(script);
+    }
+    else if (PyByteArray_Check(script)) {
+        bytes = 2;
+        Py_INCREF(script);
+        bytescript = (rchar *)PyByteArray_AS_STRING(script);
+        slength = PyByteArray_GET_SIZE(script);
+    }
+    else {
+        PyErr_SetString(PyExc_TypeError, "Unexpected type");
+        return NULL;
+    }
+
+    if (!(result = PyBytes_FromStringAndSize(NULL, slength))) {
+        LCOV_EXCL_START
+
+        Py_DECREF(script);
+        return NULL;
+
+        LCOV_EXCL_STOP
+    }
+    Py_BEGIN_ALLOW_THREADS
+    length = rjsmin(bytescript, (rchar *)PyBytes_AS_STRING(result),
+                    slength, keep_bang_comments);
+    Py_END_ALLOW_THREADS
+
+    Py_DECREF(script);
+    if (length < 0) {
+        LCOV_EXCL_START
+
+        Py_DECREF(result);
+        return NULL;
+
+        LCOV_EXCL_STOP
+    }
+
+    if (!bytes) {
+        script = PyUnicode_DecodeUTF8(PyBytes_AS_STRING(result), length,
+                                      "strict");
+        Py_DECREF(result);
+        return script;
+    }
+    if (bytes == 1) {
+        if (length != slength) {
+            _PyBytes_Resize(&result, length);
+        }
+        return result;
+    }
+    /* bytes == 2: bytearray */
+    script = PyByteArray_FromStringAndSize(PyBytes_AS_STRING(result), length);
+    Py_DECREF(result);
+    return script;
+#endif
 }
 
 /* ------------------------ BEGIN MODULE DEFINITION ------------------------ */
 
 EXT_METHODS = {
     {"jsmin",
-        (PyCFunction)rjsmin_jsmin, METH_VARARGS | METH_KEYWORDS,
+        EXT_CFUNC(rjsmin_jsmin), METH_VARARGS | METH_KEYWORDS,
         rjsmin_jsmin__doc__},
 
     {NULL}  /* Sentinel */
@@ -499,10 +707,10 @@ EXT_INIT_FUNC {
 
     /* Create the module and populate stuff */
     if (!(m = EXT_CREATE(&EXT_DEFINE_VAR)))
-        EXT_INIT_ERROR(NULL);
+        EXT_INIT_ERROR(LCOV_EXCL_LINE(NULL));
 
     EXT_ADD_UNICODE(m, "__author__", "Andr\xe9 Malo", "latin-1");
-    EXT_ADD_STRING(m, "__docformat__", "restructuredtext en");
+    EXT_ADD_STRING(m, "__version__", STRINGIFY(EXT_VERSION));
 
     EXT_INIT_RETURN(m);
 }
diff -up chromium-103.0.5060.53/third_party/catapult/common/py_vulcanize/third_party/rjsmin/rjsmin.py.12 chromium-103.0.5060.53/third_party/catapult/common/py_vulcanize/third_party/rjsmin/rjsmin.py
--- chromium-103.0.5060.53/third_party/catapult/common/py_vulcanize/third_party/rjsmin/rjsmin.py.12	2022-07-01 20:33:39.317727375 +0000
+++ chromium-103.0.5060.53/third_party/catapult/common/py_vulcanize/third_party/rjsmin/rjsmin.py	2021-11-14 20:24:16.000000000 +0000
@@ -1,6 +1,6 @@
 #!/usr/bin/env python
 # -*- coding: ascii -*-
-r"""
+u"""
 =====================
  Javascript Minifier
 =====================
@@ -11,7 +11,7 @@ The minifier is based on the semantics o
 
 :Copyright:
 
- Copyright 2011 - 2015
+ Copyright 2011 - 2021
  Andr\xe9 Malo or his licensors, as applicable
 
 :License:
@@ -39,9 +39,11 @@ same results as the original ``jsmin.c``
 - Newline characters are not allowed inside string and regex literals, except
   for line continuations in string literals (ECMA-5).
 - "return /regex/" is recognized correctly.
+- More characters are allowed before regexes.
 - Line terminators after regex literals are handled more sensibly
 - "+ +" and "- -" sequences are not collapsed to '++' or '--'
 - Newlines before ! operators are removed more sensibly
+- (Unnested) template literals are supported (ECMA-6)
 - Comments starting with an exclamation mark (``!``) can be kept optionally
 - rJSmin does not handle streams, but only complete strings. (However, the
   module provides a "streamy" interface).
@@ -56,20 +58,17 @@ file for details.
 
 rjsmin.c is a reimplementation of rjsmin.py in C and speeds it up even more.
 
-Both python 2 and python 3 are supported.
+Supported python versions are 2.7 and 3.6+.
 
 .. _jsmin.c by Douglas Crockford:
    http://www.crockford.com/javascript/jsmin.c
 """
-if __doc__:
-    # pylint: disable = redefined-builtin
-    __doc__ = __doc__.encode('ascii').decode('unicode_escape')
-__author__ = r"Andr\xe9 Malo".encode('ascii').decode('unicode_escape')
-__docformat__ = "restructuredtext en"
+__author__ = u"Andr\xe9 Malo"
 __license__ = "Apache License, Version 2.0"
-__version__ = '1.0.12'
+__version__ = '1.2.0'
 __all__ = ['jsmin']
 
+import functools as _ft
 import re as _re
 
 
@@ -80,13 +79,13 @@ def _make_jsmin(python_only=False):
     .. _jsmin.c by Douglas Crockford:
        http://www.crockford.com/javascript/jsmin.c
 
-    :Parameters:
-      `python_only` : ``bool``
+    Parameters:
+      python_only (bool):
         Use only the python variant. If true, the c extension is not even
         tried to be loaded.
 
-    :Return: Minifier
-    :Rtype: ``callable``
+    Returns:
+      callable: Minifier
     """
     # pylint: disable = unused-variable
     # pylint: disable = too-many-locals
@@ -97,7 +96,10 @@ def _make_jsmin(python_only=False):
         except ImportError:
             pass
         else:
-            return _rjsmin.jsmin
+            # Ensure that the C version is in sync
+            # https://github.com/ndparker/rjsmin/issues/11
+            if getattr(_rjsmin, '__version__', None) == __version__:
+                return _rjsmin.jsmin
     try:
         xrange
     except NameError:
@@ -110,15 +112,16 @@ def _make_jsmin(python_only=False):
     space_comment_nobang = r'(?:/\*(?!!)[^*]*\*+(?:[^/*][^*]*\*+)*/)'
     bang_comment = r'(?:/\*![^*]*\*+(?:[^/*][^*]*\*+)*/)'
 
-    string1 = \
-        r'(?:\047[^\047\\\r\n]*(?:\\(?:[^\r\n]|\r?\n|\r)[^\047\\\r\n]*)*\047)'
+    string1 = r"(?:'[^'\\\r\n]*(?:\\(?:[^\r\n]|\r?\n|\r)[^'\\\r\n]*)*')"
+    string1 = string1.replace("'", r'\047')  # portability
     string2 = r'(?:"[^"\\\r\n]*(?:\\(?:[^\r\n]|\r?\n|\r)[^"\\\r\n]*)*")'
-    string3 = r'(?:`(?:[^`\\]|\\.)*`)'
+    string3 = r'(?:`[^`\\]*(?:\\(?:[^\r\n]|\r?\n|\r)[^`\\]*)*`)'
+    string3 = string3.replace('`', r'\140')  # portability
     strings = r'(?:%s|%s|%s)' % (string1, string2, string3)
 
     charclass = r'(?:\[[^\\\]\r\n]*(?:\\[^\r\n][^\\\]\r\n]*)*\])'
     nospecial = r'[^/\\\[\r\n]'
-    regex = r'(?:/(?![\r\n/*])%s*(?:(?:\\[^\r\n]|%s)%s*)*/)' % (
+    regex = r'(?:/(?![\r\n/*])%s*(?:(?:\\[^\r\n]|%s)%s*)*/[a-z]*)' % (
         nospecial, charclass, nospecial
     )
     space = r'(?:%s|%s)' % (space_chars, space_comment)
@@ -154,7 +157,7 @@ def _make_jsmin(python_only=False):
             ) for first, last in result])  # noqa
 
         return _re.sub(
-            r'([\000-\040\047])',  # \047 for better portability
+            r"([\000-\040'`])",  # ' and ` for better portability
             lambda m: '\\%03o' % ord(m.group(1)), (
                 sequentize(result)
                 .replace('\\', '\\\\')
@@ -180,42 +183,48 @@ def _make_jsmin(python_only=False):
         return r'[%s]' % fix_charclass(result)
 
     not_id_literal = not_id_literal_(r'[a-zA-Z0-9_$]')
-    preregex1 = r'[(,=:\[!&|?{};\r\n]'
+    preregex1 = r'[(,=:\[!&|?{};\r\n+*-]'
     preregex2 = r'%(not_id_literal)sreturn' % locals()
 
     id_literal = id_literal_(r'[a-zA-Z0-9_$]')
     id_literal_open = id_literal_(r'[a-zA-Z0-9_${\[(!+-]')
-    id_literal_close = id_literal_(r'[a-zA-Z0-9_$}\])"\047+-]')
+    id_literal_close = id_literal_(r'[a-zA-Z0-9_$}\])"\047\140+-]')
     post_regex_off = id_literal_(r'[^\000-\040}\])?:|,;.&=+-]')
 
-    dull = r'[^\047"`/\000-\040]'
+    dull = r'[^\047"\140/\000-\040]'
 
     space_sub_simple = _re.compile((
-        # noqa pylint: disable = bad-continuation
+        # noqa pylint: disable = bad-option-value, bad-continuation
 
         r'(%(dull)s+)'                                         # 0
         r'|(%(strings)s%(dull)s*)'                             # 1
-        r'|(?<=%(preregex1)s)'
+        r'|(?<=[)])'
             r'%(space)s*(?:%(newline)s%(space)s*)*'
             r'(%(regex)s)'                                     # 2
-            r'(%(space)s*(?:%(newline)s%(space)s*)+'           # 3
+            r'(?=%(space)s*(?:%(newline)s%(space)s*)*'
+                r'\.'
+                r'%(space)s*(?:%(newline)s%(space)s*)*[a-z])'
+        r'|(?<=%(preregex1)s)'
+            r'%(space)s*(?:%(newline)s%(space)s*)*'
+            r'(%(regex)s)'                                     # 3
+            r'(%(space)s*(?:%(newline)s%(space)s*)+'           # 4
                 r'(?=%(post_regex_off)s))?'
         r'|(?<=%(preregex2)s)'
-            r'%(space)s*(?:(%(newline)s)%(space)s*)*'          # 4
-            r'(%(regex)s)'                                     # 5
-            r'(%(space)s*(?:%(newline)s%(space)s*)+'           # 6
+            r'%(space)s*(?:(%(newline)s)%(space)s*)*'          # 5
+            r'(%(regex)s)'                                     # 6
+            r'(%(space)s*(?:%(newline)s%(space)s*)+'           # 7
                 r'(?=%(post_regex_off)s))?'
         r'|(?<=%(id_literal_close)s)'
-            r'%(space)s*(?:(%(newline)s)%(space)s*)+'          # 7
+            r'%(space)s*(?:(%(newline)s)%(space)s*)+'          # 8
             r'(?=%(id_literal_open)s)'
-        r'|(?<=%(id_literal)s)(%(space)s)+(?=%(id_literal)s)'  # 8
-        r'|(?<=\+)(%(space)s)+(?=\+)'                          # 9
-        r'|(?<=-)(%(space)s)+(?=-)'                            # 10
+        r'|(?<=%(id_literal)s)(%(space)s)+(?=%(id_literal)s)'  # 9
+        r'|(?<=\+)(%(space)s)+(?=\+)'                          # 10
+        r'|(?<=-)(%(space)s)+(?=-)'                            # 11
         r'|%(space)s+'
         r'|(?:%(newline)s%(space)s*)+'
     ) % locals()).sub
 
-    # print space_sub_simple.__self__.pattern
+    # print(space_sub_simple.__self__.pattern)
 
     def space_subber_simple(match):
         """ Substitution callback """
@@ -227,48 +236,56 @@ def _make_jsmin(python_only=False):
         elif groups[1]:
             return groups[1]
         elif groups[2]:
-            if groups[3]:
-                return groups[2] + '\n'
             return groups[2]
-        elif groups[5]:
+        elif groups[3]:
+            if groups[4]:
+                return groups[3] + '\n'
+            return groups[3]
+        elif groups[6]:
             return "%s%s%s" % (
-                groups[4] and '\n' or '',
-                groups[5],
-                groups[6] and '\n' or '',
+                groups[5] and '\n' or '',
+                groups[6],
+                groups[7] and '\n' or '',
             )
-        elif groups[7]:
+        elif groups[8]:
             return '\n'
-        elif groups[8] or groups[9] or groups[10]:
+        elif groups[9] or groups[10] or groups[11]:
             return ' '
         else:
             return ''
 
     space_sub_banged = _re.compile((
-        # noqa pylint: disable = bad-continuation
+        # noqa pylint: disable = bad-option-value, bad-continuation
 
         r'(%(dull)s+)'                                         # 0
         r'|(%(strings)s%(dull)s*)'                             # 1
-        r'|(?<=%(preregex1)s)'
+        r'|(?<=[)])'
             r'(%(space)s*(?:%(newline)s%(space)s*)*)'          # 2
             r'(%(regex)s)'                                     # 3
-            r'(%(space)s*(?:%(newline)s%(space)s*)+'           # 4
+            r'(?=%(space)s*(?:%(newline)s%(space)s*)*'
+                r'\.'
+                r'%(space)s*(?:%(newline)s%(space)s*)*[a-z])'
+        r'|(?<=%(preregex1)s)'
+            r'(%(space)s*(?:%(newline)s%(space)s*)*)'          # 4
+            r'(%(regex)s)'                                     # 5
+            r'(%(space)s*(?:%(newline)s%(space)s*)+'           # 6
                 r'(?=%(post_regex_off)s))?'
         r'|(?<=%(preregex2)s)'
-            r'(%(space)s*(?:(%(newline)s)%(space)s*)*)'        # 5, 6
-            r'(%(regex)s)'                                     # 7
-            r'(%(space)s*(?:%(newline)s%(space)s*)+'           # 8
+            r'(%(space)s*(?:(%(newline)s)%(space)s*)*)'        # 7, 8
+            r'(%(regex)s)'                                     # 9
+            r'(%(space)s*(?:%(newline)s%(space)s*)+'           # 10
                 r'(?=%(post_regex_off)s))?'
         r'|(?<=%(id_literal_close)s)'
-            r'(%(space)s*(?:%(newline)s%(space)s*)+)'          # 9
+            r'(%(space)s*(?:%(newline)s%(space)s*)+)'          # 11
             r'(?=%(id_literal_open)s)'
-        r'|(?<=%(id_literal)s)(%(space)s+)(?=%(id_literal)s)'  # 10
-        r'|(?<=\+)(%(space)s+)(?=\+)'                          # 11
-        r'|(?<=-)(%(space)s+)(?=-)'                            # 12
-        r'|(%(space)s+)'                                       # 13
-        r'|((?:%(newline)s%(space)s*)+)'                       # 14
+        r'|(?<=%(id_literal)s)(%(space)s+)(?=%(id_literal)s)'  # 12
+        r'|(?<=\+)(%(space)s+)(?=\+)'                          # 13
+        r'|(?<=-)(%(space)s+)(?=-)'                            # 14
+        r'|(%(space)s+)'                                       # 15
+        r'|((?:%(newline)s%(space)s*)+)'                       # 16
     ) % locals()).sub
 
-    # print space_sub_banged.__self__.pattern
+    # print(space_sub_banged.__self__.pattern)
 
     keep = _re.compile((
         r'%(space_chars)s+|%(space_comment_nobang)s+|%(newline)s+'
@@ -276,7 +293,7 @@ def _make_jsmin(python_only=False):
     ) % locals()).sub
     keeper = lambda m: m.groups()[0] or ''
 
-    # print keep.__self__.pattern
+    # print(keep.__self__.pattern)
 
     def space_subber_banged(match):
         """ Substitution callback """
@@ -288,26 +305,34 @@ def _make_jsmin(python_only=False):
         elif groups[1]:
             return groups[1]
         elif groups[3]:
-            return "%s%s%s%s" % (
+            return "%s%s" % (
                 keep(keeper, groups[2]),
                 groups[3],
-                keep(keeper, groups[4] or ''),
-                groups[4] and '\n' or '',
             )
-        elif groups[7]:
-            return "%s%s%s%s%s" % (
-                keep(keeper, groups[5]),
+        elif groups[5]:
+            return "%s%s%s%s" % (
+                keep(keeper, groups[4]),
+                groups[5],
+                keep(keeper, groups[6] or ''),
                 groups[6] and '\n' or '',
-                groups[7],
-                keep(keeper, groups[8] or ''),
-                groups[8] and '\n' or '',
             )
         elif groups[9]:
-            return keep(keeper, groups[9]) + '\n'
-        elif groups[10] or groups[11] or groups[12]:
-            return keep(keeper, groups[10] or groups[11] or groups[12]) or ' '
+            return "%s%s%s%s%s" % (
+                keep(keeper, groups[7]),
+                groups[8] and '\n' or '',
+                groups[9],
+                keep(keeper, groups[10] or ''),
+                groups[10] and '\n' or '',
+            )
+        elif groups[11]:
+            return keep(keeper, groups[11]) + '\n'
+        elif groups[12] or groups[13] or groups[14]:
+            return keep(keeper, groups[12] or groups[13] or groups[14]) or ' '
         else:
-            return keep(keeper, groups[13] or groups[14])
+            return keep(keeper, groups[15] or groups[16])
+
+    banged = _ft.partial(space_sub_banged, space_subber_banged)
+    simple = _ft.partial(space_sub_simple, space_subber_simple)
 
     def jsmin(script, keep_bang_comments=False):
         r"""
@@ -320,32 +345,51 @@ def _make_jsmin(python_only=False):
         .. _jsmin.c by Douglas Crockford:
            http://www.crockford.com/javascript/jsmin.c
 
-        :Parameters:
-          `script` : ``str``
+        Parameters:
+          script (str):
             Script to minify
 
-          `keep_bang_comments` : ``bool``
+          keep_bang_comments (bool):
             Keep comments starting with an exclamation mark? (``/*!...*/``)
 
-        :Return: Minified script
-        :Rtype: ``str``
+        Returns:
+          str: Minified script
         """
         # pylint: disable = redefined-outer-name
 
-        if keep_bang_comments:
-            return space_sub_banged(
-                space_subber_banged, '\n%s\n' % script
-            ).strip()
-        else:
-            return space_sub_simple(
-                space_subber_simple, '\n%s\n' % script
-            ).strip()
+        is_bytes, script = _as_str(script)
+        script = (banged if keep_bang_comments else simple)(
+            '\n%s\n' % script
+        ).strip()
+        if is_bytes:
+            script = script.encode('latin-1')
+            if is_bytes == 2:
+                script = bytearray(script)
+        return script
 
     return jsmin
 
 jsmin = _make_jsmin()
 
 
+def _as_str(script):
+    """ Make sure the script is a text string """
+    is_bytes = False
+    if str is bytes:
+        if not isinstance(script, basestring):  # noqa pylint: disable = undefined-variable
+            raise TypeError("Unexpected type")
+    elif isinstance(script, bytes):
+        is_bytes = True
+        script = script.decode('latin-1')
+    elif isinstance(script, bytearray):
+        is_bytes = 2
+        script = script.decode('latin-1')
+    elif not isinstance(script, str):
+        raise TypeError("Unexpected type")
+
+    return is_bytes, script
+
+
 def jsmin_for_posers(script, keep_bang_comments=False):
     r"""
     Minify javascript based on `jsmin.c by Douglas Crockford`_\.
@@ -361,49 +405,61 @@ def jsmin_for_posers(script, keep_bang_c
               utilizes the resulting regexes. It's here for fun and may
               vanish any time. Use the `jsmin` function instead.
 
-    :Parameters:
-      `script` : ``str``
+    Parameters:
+      script (str):
         Script to minify
 
-      `keep_bang_comments` : ``bool``
+      keep_bang_comments (bool):
         Keep comments starting with an exclamation mark? (``/*!...*/``)
 
-    :Return: Minified script
-    :Rtype: ``str``
+    Returns:
+      str: Minified script
     """
     if not keep_bang_comments:
         rex = (
-            r'([^\047"/\000-\040]+)|((?:(?:\047[^\047\\\r\n]*(?:\\(?:[^\r\n]'
-            r'|\r?\n|\r)[^\047\\\r\n]*)*\047)|(?:"[^"\\\r\n]*(?:\\(?:[^\r\n]'
-            r'|\r?\n|\r)[^"\\\r\n]*)*"))[^\047"/\000-\040]*)|(?<=[(,=:\[!&|?'
-            r'{};\r\n])(?:[\000-\011\013\014\016-\040]|(?:/\*[^*]*\*+(?:[^/*'
-            r'][^*]*\*+)*/))*(?:(?:(?://[^\r\n]*)?[\r\n])(?:[\000-\011\013\0'
-            r'14\016-\040]|(?:/\*[^*]*\*+(?:[^/*][^*]*\*+)*/))*)*((?:/(?![\r'
-            r'\n/*])[^/\\\[\r\n]*(?:(?:\\[^\r\n]|(?:\[[^\\\]\r\n]*(?:\\[^\r'
-            r'\n][^\\\]\r\n]*)*\]))[^/\\\[\r\n]*)*/))((?:[\000-\011\013\014'
+            r'([^\047"\140/\000-\040]+)|((?:(?:\047[^\047\\\r\n]*(?:\\(?:[^'
+            r'\r\n]|\r?\n|\r)[^\047\\\r\n]*)*\047)|(?:"[^"\\\r\n]*(?:\\(?:[^'
+            r'\r\n]|\r?\n|\r)[^"\\\r\n]*)*")|(?:\140[^\140\\]*(?:\\(?:[^\r\n'
+            r']|\r?\n|\r)[^\140\\]*)*\140))[^\047"\140/\000-\040]*)|(?<=[)])'
+            r'(?:[\000-\011\013\014\016-\040]|(?:/\*[^*]*\*+(?:[^/*][^*]*\*+'
+            r')*/))*(?:(?:(?://[^\r\n]*)?[\r\n])(?:[\000-\011\013\014\016-\0'
+            r'40]|(?:/\*[^*]*\*+(?:[^/*][^*]*\*+)*/))*)*((?:/(?![\r\n/*])[^/'
+            r'\\\[\r\n]*(?:(?:\\[^\r\n]|(?:\[[^\\\]\r\n]*(?:\\[^\r\n][^\\\]'
+            r'\r\n]*)*\]))[^/\\\[\r\n]*)*/[a-z]*))(?=(?:[\000-\011\013\014\0'
+            r'16-\040]|(?:/\*[^*]*\*+(?:[^/*][^*]*\*+)*/))*(?:(?:(?://[^\r\n'
+            r']*)?[\r\n])(?:[\000-\011\013\014\016-\040]|(?:/\*[^*]*\*+(?:[^'
+            r'/*][^*]*\*+)*/))*)*\.(?:[\000-\011\013\014\016-\040]|(?:/\*[^*'
+            r']*\*+(?:[^/*][^*]*\*+)*/))*(?:(?:(?://[^\r\n]*)?[\r\n])(?:[\00'
+            r'0-\011\013\014\016-\040]|(?:/\*[^*]*\*+(?:[^/*][^*]*\*+)*/))*)'
+            r'*[a-z])|(?<=[(,=:\[!&|?{};\r\n+*-])(?:[\000-\011\013\014\016-'
+            r'\040]|(?:/\*[^*]*\*+(?:[^/*][^*]*\*+)*/))*(?:(?:(?://[^\r\n]*)'
+            r'?[\r\n])(?:[\000-\011\013\014\016-\040]|(?:/\*[^*]*\*+(?:[^/*]'
+            r'[^*]*\*+)*/))*)*((?:/(?![\r\n/*])[^/\\\[\r\n]*(?:(?:\\[^\r\n]|'
+            r'(?:\[[^\\\]\r\n]*(?:\\[^\r\n][^\\\]\r\n]*)*\]))[^/\\\[\r\n]*)*'
+            r'/[a-z]*))((?:[\000-\011\013\014\016-\040]|(?:/\*[^*]*\*+(?:[^/'
+            r'*][^*]*\*+)*/))*(?:(?:(?://[^\r\n]*)?[\r\n])(?:[\000-\011\013'
+            r'\014\016-\040]|(?:/\*[^*]*\*+(?:[^/*][^*]*\*+)*/))*)+(?=[^\000'
+            r'-\040&)+,.:;=?\]|}-]))?|(?<=[\000-#%-,./:-@\[-^\140{-~-]return'
+            r')(?:[\000-\011\013\014\016-\040]|(?:/\*[^*]*\*+(?:[^/*][^*]*\*'
+            r'+)*/))*(?:((?:(?://[^\r\n]*)?[\r\n]))(?:[\000-\011\013\014\016'
+            r'-\040]|(?:/\*[^*]*\*+(?:[^/*][^*]*\*+)*/))*)*((?:/(?![\r\n/*])'
+            r'[^/\\\[\r\n]*(?:(?:\\[^\r\n]|(?:\[[^\\\]\r\n]*(?:\\[^\r\n][^'
+            r'\\\]\r\n]*)*\]))[^/\\\[\r\n]*)*/[a-z]*))((?:[\000-\011\013\014'
             r'\016-\040]|(?:/\*[^*]*\*+(?:[^/*][^*]*\*+)*/))*(?:(?:(?://[^\r'
             r'\n]*)?[\r\n])(?:[\000-\011\013\014\016-\040]|(?:/\*[^*]*\*+(?:'
-            r'[^/*][^*]*\*+)*/))*)+(?=[^\000-\040&)+,.:;=?\]|}-]))?|(?<=[\00'
-            r'0-#%-,./:-@\[-^`{-~-]return)(?:[\000-\011\013\014\016-\040]|(?'
-            r':/\*[^*]*\*+(?:[^/*][^*]*\*+)*/))*(?:((?:(?://[^\r\n]*)?[\r\n]'
-            r'))(?:[\000-\011\013\014\016-\040]|(?:/\*[^*]*\*+(?:[^/*][^*]*'
-            r'\*+)*/))*)*((?:/(?![\r\n/*])[^/\\\[\r\n]*(?:(?:\\[^\r\n]|(?:\['
-            r'[^\\\]\r\n]*(?:\\[^\r\n][^\\\]\r\n]*)*\]))[^/\\\[\r\n]*)*/))(('
-            r'?:[\000-\011\013\014\016-\040]|(?:/\*[^*]*\*+(?:[^/*][^*]*\*+)'
-            r'*/))*(?:(?:(?://[^\r\n]*)?[\r\n])(?:[\000-\011\013\014\016-\04'
-            r'0]|(?:/\*[^*]*\*+(?:[^/*][^*]*\*+)*/))*)+(?=[^\000-\040&)+,.:;'
-            r'=?\]|}-]))?|(?<=[^\000-!#%&(*,./:-@\[\\^`{|~])(?:[\000-\011\01'
-            r'3\014\016-\040]|(?:/\*[^*]*\*+(?:[^/*][^*]*\*+)*/))*(?:((?:(?:'
-            r'//[^\r\n]*)?[\r\n]))(?:[\000-\011\013\014\016-\040]|(?:/\*[^*]'
-            r'*\*+(?:[^/*][^*]*\*+)*/))*)+(?=[^\000-\040"#%-\047)*,./:-@\\-^'
-            r'`|-~])|(?<=[^\000-#%-,./:-@\[-^`{-~-])((?:[\000-\011\013\014\0'
-            r'16-\040]|(?:/\*[^*]*\*+(?:[^/*][^*]*\*+)*/)))+(?=[^\000-#%-,./'
-            r':-@\[-^`{-~-])|(?<=\+)((?:[\000-\011\013\014\016-\040]|(?:/\*['
-            r'^*]*\*+(?:[^/*][^*]*\*+)*/)))+(?=\+)|(?<=-)((?:[\000-\011\013'
-            r'\014\016-\040]|(?:/\*[^*]*\*+(?:[^/*][^*]*\*+)*/)))+(?=-)|(?:['
-            r'\000-\011\013\014\016-\040]|(?:/\*[^*]*\*+(?:[^/*][^*]*\*+)*/)'
-            r')+|(?:(?:(?://[^\r\n]*)?[\r\n])(?:[\000-\011\013\014\016-\040]'
-            r'|(?:/\*[^*]*\*+(?:[^/*][^*]*\*+)*/))*)+'
+            r'[^/*][^*]*\*+)*/))*)+(?=[^\000-\040&)+,.:;=?\]|}-]))?|(?<=[^\0'
+            r'00-!#%&(*,./:-@\[\\^{|~])(?:[\000-\011\013\014\016-\040]|(?:/'
+            r'\*[^*]*\*+(?:[^/*][^*]*\*+)*/))*(?:((?:(?://[^\r\n]*)?[\r\n]))'
+            r'(?:[\000-\011\013\014\016-\040]|(?:/\*[^*]*\*+(?:[^/*][^*]*\*+'
+            r')*/))*)+(?=[^\000-\040"#%-\047)*,./:-@\\-^\140|-~])|(?<=[^\000'
+            r'-#%-,./:-@\[-^\140{-~-])((?:[\000-\011\013\014\016-\040]|(?:/'
+            r'\*[^*]*\*+(?:[^/*][^*]*\*+)*/)))+(?=[^\000-#%-,./:-@\[-^\140{-'
+            r'~-])|(?<=\+)((?:[\000-\011\013\014\016-\040]|(?:/\*[^*]*\*+(?:'
+            r'[^/*][^*]*\*+)*/)))+(?=\+)|(?<=-)((?:[\000-\011\013\014\016-\0'
+            r'40]|(?:/\*[^*]*\*+(?:[^/*][^*]*\*+)*/)))+(?=-)|(?:[\000-\011\0'
+            r'13\014\016-\040]|(?:/\*[^*]*\*+(?:[^/*][^*]*\*+)*/))+|(?:(?:(?'
+            r'://[^\r\n]*)?[\r\n])(?:[\000-\011\013\014\016-\040]|(?:/\*[^*]'
+            r'*\*+(?:[^/*][^*]*\*+)*/))*)+'
         )
 
         def subber(match):
@@ -412,59 +468,72 @@ def jsmin_for_posers(script, keep_bang_c
             return (
                 groups[0] or
                 groups[1] or
-                (groups[3] and (groups[2] + '\n')) or
                 groups[2] or
-                (groups[5] and "%s%s%s" % (
-                    groups[4] and '\n' or '',
-                    groups[5],
-                    groups[6] and '\n' or '',
+                (groups[4] and (groups[3] + '\n')) or
+                groups[3] or
+                (groups[6] and "%s%s%s" % (
+                    groups[5] and '\n' or '',
+                    groups[6],
+                    groups[7] and '\n' or '',
                 )) or
-                (groups[7] and '\n') or
-                (groups[8] and ' ') or
+                (groups[8] and '\n') or
                 (groups[9] and ' ') or
                 (groups[10] and ' ') or
+                (groups[11] and ' ') or
                 ''
             )
     else:
         rex = (
-            r'([^\047"/\000-\040]+)|((?:(?:\047[^\047\\\r\n]*(?:\\(?:[^\r\n]'
-            r'|\r?\n|\r)[^\047\\\r\n]*)*\047)|(?:"[^"\\\r\n]*(?:\\(?:[^\r\n]'
-            r'|\r?\n|\r)[^"\\\r\n]*)*"))[^\047"/\000-\040]*)|(?<=[(,=:\[!&|?'
-            r'{};\r\n])((?:[\000-\011\013\014\016-\040]|(?:/\*[^*]*\*+(?:[^/'
-            r'*][^*]*\*+)*/))*(?:(?:(?://[^\r\n]*)?[\r\n])(?:[\000-\011\013'
-            r'\014\016-\040]|(?:/\*[^*]*\*+(?:[^/*][^*]*\*+)*/))*)*)((?:/(?!'
-            r'[\r\n/*])[^/\\\[\r\n]*(?:(?:\\[^\r\n]|(?:\[[^\\\]\r\n]*(?:\\[^'
-            r'\r\n][^\\\]\r\n]*)*\]))[^/\\\[\r\n]*)*/))((?:[\000-\011\013\01'
-            r'4\016-\040]|(?:/\*[^*]*\*+(?:[^/*][^*]*\*+)*/))*(?:(?:(?://[^'
+            r'([^\047"\140/\000-\040]+)|((?:(?:\047[^\047\\\r\n]*(?:\\(?:[^'
+            r'\r\n]|\r?\n|\r)[^\047\\\r\n]*)*\047)|(?:"[^"\\\r\n]*(?:\\(?:[^'
+            r'\r\n]|\r?\n|\r)[^"\\\r\n]*)*")|(?:\140[^\140\\]*(?:\\(?:[^\r\n'
+            r']|\r?\n|\r)[^\140\\]*)*\140))[^\047"\140/\000-\040]*)|(?<=[)])'
+            r'((?:[\000-\011\013\014\016-\040]|(?:/\*[^*]*\*+(?:[^/*][^*]*\*'
+            r'+)*/))*(?:(?:(?://[^\r\n]*)?[\r\n])(?:[\000-\011\013\014\016-'
+            r'\040]|(?:/\*[^*]*\*+(?:[^/*][^*]*\*+)*/))*)*)((?:/(?![\r\n/*])'
+            r'[^/\\\[\r\n]*(?:(?:\\[^\r\n]|(?:\[[^\\\]\r\n]*(?:\\[^\r\n][^'
+            r'\\\]\r\n]*)*\]))[^/\\\[\r\n]*)*/[a-z]*))(?=(?:[\000-\011\013\0'
+            r'14\016-\040]|(?:/\*[^*]*\*+(?:[^/*][^*]*\*+)*/))*(?:(?:(?://[^'
             r'\r\n]*)?[\r\n])(?:[\000-\011\013\014\016-\040]|(?:/\*[^*]*\*+('
-            r'?:[^/*][^*]*\*+)*/))*)+(?=[^\000-\040&)+,.:;=?\]|}-]))?|(?<=['
-            r'\000-#%-,./:-@\[-^`{-~-]return)((?:[\000-\011\013\014\016-\040'
-            r']|(?:/\*[^*]*\*+(?:[^/*][^*]*\*+)*/))*(?:((?:(?://[^\r\n]*)?['
-            r'\r\n]))(?:[\000-\011\013\014\016-\040]|(?:/\*[^*]*\*+(?:[^/*]['
-            r'^*]*\*+)*/))*)*)((?:/(?![\r\n/*])[^/\\\[\r\n]*(?:(?:\\[^\r\n]|'
-            r'(?:\[[^\\\]\r\n]*(?:\\[^\r\n][^\\\]\r\n]*)*\]))[^/\\\[\r\n]*)*'
-            r'/))((?:[\000-\011\013\014\016-\040]|(?:/\*[^*]*\*+(?:[^/*][^*]'
-            r'*\*+)*/))*(?:(?:(?://[^\r\n]*)?[\r\n])(?:[\000-\011\013\014\01'
-            r'6-\040]|(?:/\*[^*]*\*+(?:[^/*][^*]*\*+)*/))*)+(?=[^\000-\040&)'
-            r'+,.:;=?\]|}-]))?|(?<=[^\000-!#%&(*,./:-@\[\\^`{|~])((?:[\000-'
-            r'\011\013\014\016-\040]|(?:/\*[^*]*\*+(?:[^/*][^*]*\*+)*/))*(?:'
-            r'(?:(?://[^\r\n]*)?[\r\n])(?:[\000-\011\013\014\016-\040]|(?:/'
-            r'\*[^*]*\*+(?:[^/*][^*]*\*+)*/))*)+)(?=[^\000-\040"#%-\047)*,./'
-            r':-@\\-^`|-~])|(?<=[^\000-#%-,./:-@\[-^`{-~-])((?:[\000-\011\01'
-            r'3\014\016-\040]|(?:/\*[^*]*\*+(?:[^/*][^*]*\*+)*/))+)(?=[^\000'
-            r'-#%-,./:-@\[-^`{-~-])|(?<=\+)((?:[\000-\011\013\014\016-\040]|'
-            r'(?:/\*[^*]*\*+(?:[^/*][^*]*\*+)*/))+)(?=\+)|(?<=-)((?:[\000-\0'
-            r'11\013\014\016-\040]|(?:/\*[^*]*\*+(?:[^/*][^*]*\*+)*/))+)(?=-'
-            r')|((?:[\000-\011\013\014\016-\040]|(?:/\*[^*]*\*+(?:[^/*][^*]*'
-            r'\*+)*/))+)|((?:(?:(?://[^\r\n]*)?[\r\n])(?:[\000-\011\013\014'
-            r'\016-\040]|(?:/\*[^*]*\*+(?:[^/*][^*]*\*+)*/))*)+)'
+            r'?:[^/*][^*]*\*+)*/))*)*\.(?:[\000-\011\013\014\016-\040]|(?:/'
+            r'\*[^*]*\*+(?:[^/*][^*]*\*+)*/))*(?:(?:(?://[^\r\n]*)?[\r\n])(?'
+            r':[\000-\011\013\014\016-\040]|(?:/\*[^*]*\*+(?:[^/*][^*]*\*+)*'
+            r'/))*)*[a-z])|(?<=[(,=:\[!&|?{};\r\n+*-])((?:[\000-\011\013\014'
+            r'\016-\040]|(?:/\*[^*]*\*+(?:[^/*][^*]*\*+)*/))*(?:(?:(?://[^\r'
+            r'\n]*)?[\r\n])(?:[\000-\011\013\014\016-\040]|(?:/\*[^*]*\*+(?:'
+            r'[^/*][^*]*\*+)*/))*)*)((?:/(?![\r\n/*])[^/\\\[\r\n]*(?:(?:\\[^'
+            r'\r\n]|(?:\[[^\\\]\r\n]*(?:\\[^\r\n][^\\\]\r\n]*)*\]))[^/\\\[\r'
+            r'\n]*)*/[a-z]*))((?:[\000-\011\013\014\016-\040]|(?:/\*[^*]*\*+'
+            r'(?:[^/*][^*]*\*+)*/))*(?:(?:(?://[^\r\n]*)?[\r\n])(?:[\000-\01'
+            r'1\013\014\016-\040]|(?:/\*[^*]*\*+(?:[^/*][^*]*\*+)*/))*)+(?=['
+            r'^\000-\040&)+,.:;=?\]|}-]))?|(?<=[\000-#%-,./:-@\[-^\140{-~-]r'
+            r'eturn)((?:[\000-\011\013\014\016-\040]|(?:/\*[^*]*\*+(?:[^/*]['
+            r'^*]*\*+)*/))*(?:((?:(?://[^\r\n]*)?[\r\n]))(?:[\000-\011\013\0'
+            r'14\016-\040]|(?:/\*[^*]*\*+(?:[^/*][^*]*\*+)*/))*)*)((?:/(?!['
+            r'\r\n/*])[^/\\\[\r\n]*(?:(?:\\[^\r\n]|(?:\[[^\\\]\r\n]*(?:\\[^'
+            r'\r\n][^\\\]\r\n]*)*\]))[^/\\\[\r\n]*)*/[a-z]*))((?:[\000-\011'
+            r'\013\014\016-\040]|(?:/\*[^*]*\*+(?:[^/*][^*]*\*+)*/))*(?:(?:('
+            r'?://[^\r\n]*)?[\r\n])(?:[\000-\011\013\014\016-\040]|(?:/\*[^*'
+            r']*\*+(?:[^/*][^*]*\*+)*/))*)+(?=[^\000-\040&)+,.:;=?\]|}-]))?|'
+            r'(?<=[^\000-!#%&(*,./:-@\[\\^{|~])((?:[\000-\011\013\014\016-\0'
+            r'40]|(?:/\*[^*]*\*+(?:[^/*][^*]*\*+)*/))*(?:(?:(?://[^\r\n]*)?['
+            r'\r\n])(?:[\000-\011\013\014\016-\040]|(?:/\*[^*]*\*+(?:[^/*][^'
+            r'*]*\*+)*/))*)+)(?=[^\000-\040"#%-\047)*,./:-@\\-^\140|-~])|(?<'
+            r'=[^\000-#%-,./:-@\[-^\140{-~-])((?:[\000-\011\013\014\016-\040'
+            r']|(?:/\*[^*]*\*+(?:[^/*][^*]*\*+)*/))+)(?=[^\000-#%-,./:-@\[-^'
+            r'\140{-~-])|(?<=\+)((?:[\000-\011\013\014\016-\040]|(?:/\*[^*]*'
+            r'\*+(?:[^/*][^*]*\*+)*/))+)(?=\+)|(?<=-)((?:[\000-\011\013\014'
+            r'\016-\040]|(?:/\*[^*]*\*+(?:[^/*][^*]*\*+)*/))+)(?=-)|((?:[\00'
+            r'0-\011\013\014\016-\040]|(?:/\*[^*]*\*+(?:[^/*][^*]*\*+)*/))+)'
+            r'|((?:(?:(?://[^\r\n]*)?[\r\n])(?:[\000-\011\013\014\016-\040]|'
+            r'(?:/\*[^*]*\*+(?:[^/*][^*]*\*+)*/))*)+)'
         )
 
-        keep = _re.compile((
+        keep = _re.compile(
             r'[\000-\011\013\014\016-\040]+|(?:/\*(?!!)[^*]*\*+(?:[^/*][^*]*'
             r'\*+)*/)+|(?:(?://[^\r\n]*)?[\r\n])+|((?:/\*![^*]*\*+(?:[^/*][^'
             r'*]*\*+)*/)+)'
-        ) % locals()).sub
+        ).sub
         keeper = lambda m: m.groups()[0] or ''
 
         def subber(match):
@@ -473,27 +542,37 @@ def jsmin_for_posers(script, keep_bang_c
             return (
                 groups[0] or
                 groups[1] or
-                (groups[3] and "%s%s%s%s" % (
+                groups[3] and "%s%s" % (
                     keep(keeper, groups[2]),
                     groups[3],
-                    keep(keeper, groups[4] or ''),
-                    groups[4] and '\n' or '',
-                )) or
-                (groups[7] and "%s%s%s%s%s" % (
-                    keep(keeper, groups[5]),
+                ) or
+                groups[5] and "%s%s%s%s" % (
+                    keep(keeper, groups[4]),
+                    groups[5],
+                    keep(keeper, groups[6] or ''),
                     groups[6] and '\n' or '',
-                    groups[7],
-                    keep(keeper, groups[8] or ''),
+                ) or
+                groups[9] and "%s%s%s%s%s" % (
+                    keep(keeper, groups[7]),
                     groups[8] and '\n' or '',
-                )) or
-                (groups[9] and keep(keeper, groups[9] + '\n')) or
-                (groups[10] and keep(keeper, groups[10]) or ' ') or
-                (groups[11] and keep(keeper, groups[11]) or ' ') or
-                (groups[12] and keep(keeper, groups[12]) or ' ') or
-                keep(keeper, groups[13] or groups[14])
+                    groups[9],
+                    keep(keeper, groups[10] or ''),
+                    groups[10] and '\n' or '',
+                ) or
+                groups[11] and (keep(keeper, groups[11]) + '\n') or
+                groups[12] and (keep(keeper, groups[12]) or ' ') or
+                groups[13] and (keep(keeper, groups[13]) or ' ') or
+                groups[14] and (keep(keeper, groups[14]) or ' ') or
+                keep(keeper, groups[15] or groups[16])
             )
 
-    return _re.sub(rex, subber, '\n%s\n' % script).strip()
+    is_bytes, script = _as_str(script)
+    script = _re.sub(rex, subber, '\n%s\n' % script).strip()
+    if is_bytes:
+        script = script.encode('latin-1')
+        if is_bytes == 2:
+            script = bytearray(script)
+    return script
 
 
 if __name__ == '__main__':
diff -up chromium-103.0.5060.53/third_party/catapult/common/py_vulcanize/third_party/rjsmin/setup.py.12 chromium-103.0.5060.53/third_party/catapult/common/py_vulcanize/third_party/rjsmin/setup.py
--- chromium-103.0.5060.53/third_party/catapult/common/py_vulcanize/third_party/rjsmin/setup.py.12	2022-06-28 12:50:10.171324444 +0000
+++ chromium-103.0.5060.53/third_party/catapult/common/py_vulcanize/third_party/rjsmin/setup.py	2021-11-05 17:03:12.000000000 +0000
@@ -1,41 +1,264 @@
 #!/usr/bin/env python
 # -*- coding: ascii -*-
-#
-# Copyright 2006 - 2013
-# Andr\xe9 Malo or his licensors, as applicable
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
+u"""
+:Copyright:
 
+ Copyright 2011 - 2021
+ Andr\xe9 Malo or his licensors, as applicable
+
+:License:
+
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+
+===========================================
+ rJSmin - A Javascript Minifier For Python
+===========================================
+
+rJSmin - A Javascript Minifier For Python.
+"""
+from __future__ import print_function
+__author__ = u"Andr\xe9 Malo"
+__docformat__ = "restructuredtext en"
+
+import os as _os
+import posixpath as _posixpath
 import sys as _sys
-from _setup import run
 
+# pylint: disable = no-name-in-module, import-error, raise-missing-from
+import setuptools as _setuptools
+
+# pylint: disable = invalid-name
+
+
+def _doc(filename):
+    """ Read docs file """
+    # pylint: disable = unspecified-encoding
+    args = {} if str is bytes else dict(encoding='utf-8')
+    try:
+        with open(_os.path.join('docs', filename), **args) as fp:
+            return fp.read()
+    except IOError:
+        return None
+
+
+def _lines(multiline):
+    """ Split multiline string into single line % empty and comments """
+    return [line for line in (
+        line.strip() for line in multiline.splitlines(False)
+    ) if line and not line.startswith('#')]
+
+
+package = dict(
+    name='rjsmin',
+    top='.',
+    pathname='.',
+    provides=_doc('PROVIDES'),
+    desc=_doc('SUMMARY').strip(),
+    longdesc=_doc('DESCRIPTION'),
+    author=__author__,
+    email='nd@perlig.de',
+    license="Apache License, Version 2.0",
+    keywords=_lines(_doc('KEYWORDS')),
+    url='http://opensource.perlig.de/rjsmin/',
+    classifiers=_lines(_doc('CLASSIFIERS') or ''),
+
+    packages=False,
+    py_modules=['rjsmin'],
+    version_file='rjsmin.py',
+    install_requires=[],
+)
+
+
+class BuildFailed(Exception):
+    """ The build has failed """
+
+
+from distutils.command import build_ext as _build_ext  # pylint: disable = wrong-import-order
+from distutils import errors as _errors  # pylint: disable = wrong-import-order
+class build_ext(_build_ext.build_ext):  # pylint: disable = no-init
+    """ Improved extension building code """
+
+    def run(self):
+        """ Unify exception """
+        try:
+            _build_ext.build_ext.run(self)
+        except _errors.DistutilsPlatformError:
+            raise BuildFailed()
+
+
+    def build_extension(self, ext):
+        """
+        Build C extension - with extended functionality
 
-def setup(args=None, _manifest=0):
-    """ Main setup function """
-    from _setup.ext import Extension
+        The following features are added here:
 
-    if 'java' in _sys.platform.lower():
-        # no c extension for jython
-        ext = None
+        - The macros ``EXT_PACKAGE`` and ``EXT_MODULE`` will be filled (or
+          unset) depending on the extensions name, but only if they are not
+          already defined.
+
+        - "." is added to the include directories (for cext.h)
+
+        :Parameters:
+          `ext` : `Extension`
+            The extension to build
+
+        :Return: whatever ``distutils.command.build_ext.build_ext`` returns
+        :Rtype: any
+        """
+        # handle name macros
+        macros = dict(ext.define_macros or ())
+        tup = ext.name.split('.')
+        if len(tup) == 1:
+            pkg, mod = None, tup[0]
+        else:
+            pkg, mod = '.'.join(tup[:-1]), tup[-1]
+        if pkg is not None and 'EXT_PACKAGE' not in macros:
+            ext.define_macros.append(('EXT_PACKAGE', pkg))
+        if 'EXT_MODULE' not in macros:
+            ext.define_macros.append(('EXT_MODULE', mod))
+        if pkg is None:
+            macros = dict(ext.undef_macros or ())
+            if 'EXT_PACKAGE' not in macros:
+                ext.undef_macros.append('EXT_PACKAGE')
+
+        import pprint; pprint.pprint(ext.__dict__)
+        try:
+            return _build_ext.build_ext.build_extension(self, ext)
+        except (_errors.CCompilerError, _errors.DistutilsExecError,
+                _errors.DistutilsPlatformError, IOError, ValueError):
+            raise BuildFailed()
+
+
+class Extension(_setuptools.Extension):
+    """ improved functionality """
+
+    def __init__(self, *args, **kwargs):
+        """ Initialization """
+        version = kwargs.pop('version')
+        self.depends = []
+        if 'depends' in kwargs:
+            self.depends = kwargs['depends']
+        _setuptools.Extension.__init__(self, *args, **kwargs)
+        self.define_macros.append(('EXT_VERSION', version))
+
+        # add include path
+        included = '.'
+        if included not in self.include_dirs:
+            self.include_dirs.append(included)
+
+        # add cext.h to the dependencies
+        cext_h = _posixpath.normpath(_posixpath.join(included, 'cext.h'))
+        for item in self.depends:
+            if _posixpath.normpath(item) == cext_h:
+                break
+        else:
+            self.depends.append(cext_h)
+
+
+EXTENSIONS = lambda v: [Extension('_rjsmin', ["rjsmin.c"], version=v)]
+
+
+def do_setup(cext):
+    """ Main """
+    # pylint: disable = too-many-branches
+    # pylint: disable = unspecified-encoding
+
+    args = {} if str is bytes else dict(encoding='utf-8')
+    version_file = '%s/%s' % (package['pathname'],
+                              package.get('version_file', '__init__.py'))
+    with open(version_file, **args) as fp:
+        for line in fp:  # pylint: disable = redefined-outer-name
+            if line.startswith('__version__'):
+                version = line.split('=', 1)[1].strip()
+                if version.startswith(("'", '"')):
+                    version = version[1:-1].strip()
+                break
+        else:
+            raise RuntimeError("Version not found")
+
+    kwargs = {}
+
+    if not cext or 'java' in _sys.platform.lower():
+        extensions = []
     else:
-        ext=[Extension('_rjsmin', sources=['rjsmin.c'])]
+        extensions = EXTENSIONS(version)
+
+    if extensions:
+        if 'build_ext' in globals():
+            kwargs.setdefault('cmdclass', {})['build_ext'] = build_ext
+        kwargs['ext_modules'] = extensions
+
+        cflags = None
+        if _os.environ.get('CFLAGS') is None:
+            from distutils import ccompiler as _ccompiler
+
+            compiler = _ccompiler.get_default_compiler()
+            try:
+                with open("debug.%s.cflags" % compiler) as fp:
+                    cflags = ' '.join([
+                        line for line in (line.strip() for line in fp)
+                        if line and not line.startswith('#')
+                    ]).split() or None
+            except IOError:
+                pass
+
+        if cflags:
+            gcov = 'coverage' in ' '.join(cflags)
+            for ext in extensions:
+                # pylint: disable = attribute-defined-outside-init
+                ext.extra_compile_args = \
+                    getattr(ext, 'extra_compile_args', []) + cflags
+                if gcov:
+                    ext.libraries.append('gcov')
+
+
+    if package.get('packages', True):
+        kwargs['packages'] = [package['top']] + [
+            '%s.%s' % (package['top'], item)
+            for item in
+            _setuptools.find_packages(package['pathname'])
+        ]
+    if package.get('py_modules'):
+        kwargs['py_modules'] = package['py_modules']
 
-    return run(script_args=args, ext=ext, manifest_only=_manifest)
+    _setuptools.setup(
+        name=package['name'],
+        author=package['author'],
+        author_email=package['email'],
+        license=package['license'],
+        classifiers=package['classifiers'],
+        description=package['desc'],
+        long_description=package['longdesc'],
+        url=package['url'],
+        install_requires=package['install_requires'],
+        version=version,
+        zip_safe=False,
+        **kwargs
+    )
 
 
-def manifest():
-    """ Create List of packaged files """
-    return setup((), _manifest=1)
+def setup():
+    """ Run setup """
+    try:
+        do_setup(True)
+    except BuildFailed:
+        env = 'SETUP_CEXT_REQUIRED'
+        if _os.environ.get(env, '') not in ('', '0'):
+            raise
+        print("C extension build failed - building python only version now. "
+              "Set '%s' environment variable to '1' to make it fail."
+              % (env,), file=_sys.stderr)
+        do_setup(False)
 
 
 if __name__ == '__main__':
